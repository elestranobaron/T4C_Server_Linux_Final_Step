#include "stdafx.h"
#include "Commands.h"
#include <algorithm>

using namespace std;

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

Commands::Commands()
{
}

Commands::~Commands()
{
    list< ScriptItem * >::iterator i;
    for( i = itemList.begin(); i != itemList.end(); i++ ){
        delete *i;
    }
}

Commands *Commands::GetInstance(){
    static Commands cmd;
    return &cmd;
}

//////////////////////////////////////////////////////////////////////////////////////////
void Commands::LoadFunctions( void )
//////////////////////////////////////////////////////////////////////////////////////////
// Loads all the supported functions.
// 
//////////////////////////////////////////////////////////////////////////////////////////
{
    ConditionalCommand *ccmd = new ConditionalCommand;
    ccmd->valueType = TITEM;
    ccmd->reqTo = false;
    CreateItem( ccmd, 1,  "GiveItem", "Give an item to the player.", 0, 0, 0 );

    ccmd = new ConditionalCommand;
    ccmd->valueType = TNUMBER;
    ccmd->reqTo = false;
    CreateItem( ccmd, 2,  "GiveXP", "Gives xp to the player.", 0, 0, 0 );

    ccmd = new ConditionalCommand;
    ccmd->valueType = TFLAG;
    ccmd->reqTo = true;
    CreateItem( ccmd, 3,  "SetFlag", "Set a flag on the player to a given value.", 0, 0, 0 );

    ccmd = new ConditionalCommand;
    ccmd->valueType = TNUMBER;
    ccmd->reqTo = false;
    CreateItem( ccmd, 4,  "HealPlayer", "Heals the player's hit points.", 0, 0, 0 );

    ConditionalText *tcmd = new ConditionalText;
    CreateItem( tcmd, 5,  "Text", "Makes the NPC say something.", 0, 0, 0 );
    
    Command *ncmd = new Command;
    CreateItem( ncmd, 6,  "BreakConversation", "Make the NPC abruptly end the conversation with the player.", 0, 0, 0 );

    ncmd = new Command;
    CreateItem( ncmd, 7,  "FightPlayer", "Make the NPC fight the player.", 0, 0, 0 );

    ccmd = new ConditionalCommand;
    ccmd->valueType = TITEM;
    ccmd->reqTo = false;
    CreateItem( ccmd, 8,  "TakeItem", "Take an item from the player.", 0, 0, 0 );

    
    ConditionalTeleport *telcmd = new ConditionalTeleport;
    CreateItem( telcmd, 9,  "Teleport", "Teleports a user to a given location.", 0, 0, 0 );

    ccmd = new ConditionalCommand;
    ccmd->valueType = TSPELL;
    ccmd->reqTo = false;
    CreateItem( ccmd, 10,  "CastSpell", "Cast a spell on the player.", 0, 0, 0 );

    ccmd = new ConditionalCommand;
    ccmd->valueType = TSPELL;
    ccmd->reqTo = false;
    CreateItem( ccmd, 11,  "CastSpellSelf", "Cast a spell on the NPC.", 0, 0, 0 );

    ccmd = new ConditionalCommand;
    ccmd->valueType = TNUMBER;
    ccmd->reqTo = false;
    CreateItem( ccmd, 12,  "GiveGold", "Gives an amount of gold to the player.", 0, 0, 0 );
	
    ccmd = new ConditionalCommand;
    ccmd->valueType = TNUMBER;
    ccmd->reqTo = false;
    CreateItem( ccmd, 13,  "TakeGold", "Takes an amount of gold from the player.", 0, 0, 0 );

	ncmd = new Command;
    CreateItem( ncmd, 14,  "PrivateSystemMessage", "Sends a local system message to the player.", 0, 0, 0 );

	ncmd = new Command;
    CreateItem( ncmd, 15,  "GlobalSystemMessage", "Sends a global system message to the player.", 0, 0, 0 );

	ncmd = new Command;
    CreateItem( ncmd, 16,  "ShoutMessage", "Sends a message on the CC Main.", 0, 0, 0 );

	ccmd = new ConditionalCommand;
    ccmd->valueType = TFLAG;
    ccmd->reqTo = true;
    CreateItem( ccmd, 17,  "SetGlobalFlag", "Set a Global flag to a given value.", 0, 0, 0 );

	ccmd = new ConditionalCommand;
    ccmd->valueType = TNUMBER;
    ccmd->reqTo = false;
    CreateItem( ccmd, 18,  "GiveKarma", "Gives karma to the player.", 0, 0, 0 );

}


//////////////////////////////////////////////////////////////////////////////////////////
ScriptItem *Commands::CreateItem
//////////////////////////////////////////////////////////////////////////////////////////
// Creates a single control flow object.
// 
(
 ScriptItem *flow,
 DWORD id,    // The flow's ID.
 string name, // The flow's name
 string help,  // Its help text.
 DWORD  img,
 DWORD  selectedImg,
 HTREEITEM parentFolder
)
// Return: FlowControl, a brand new valid FlowControl object
//////////////////////////////////////////////////////////////////////////////////////////
{  
    flow->name = name;
    flow->displayName = name;
    flow->help = help;
    flow->id = id;
    flow->img = img;
    flow->selectedImg =selectedImg;
    
    itemList.push_back( flow );

    return flow;
}

//////////////////////////////////////////////////////////////////////////////////////////
void Commands::LoadMisc( void )
//////////////////////////////////////////////////////////////////////////////////////////
// Load the miscellaneous items.
// 
//////////////////////////////////////////////////////////////////////////////////////////
{
    
    Keyword *kw = new Keyword;
    CreateItem( kw, 0, "Keyword", "Creates a new keyword. Can only be added to an OnTalk event.", 0, 0, 0 );
}

//////////////////////////////////////////////////////////////////////////////////////////
void Commands::LoadCommands
//////////////////////////////////////////////////////////////////////////////////////////
// Loads the commands from the database to the given dialog editor.
// 
(
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    LoadFunctions();
    LoadMisc();
}

//////////////////////////////////////////////////////////////////////////////////////////
list< ScriptItem * > *Commands::CreateScriptItem
//////////////////////////////////////////////////////////////////////////////////////////
// Create the given script item.
// 
(
 DWORD id, // The Id
 ScriptItem::ItemType itemType, // The type.
 bool &rootOnly
)
// Return: ScriptItem, a valid ScriptItem pointer, NULL if the command doesn't exist.
//////////////////////////////////////////////////////////////////////////////////////////
{
    list< ScriptItem * >::iterator i;
    for( i = itemList.begin(); i != itemList.end(); i++ ){
        if( (*i)->GetId() == id && (*i)->GetType() == itemType ){
            return (*i)->Clone( rootOnly );
        }
    }

    return NULL;
}


// Constructor ///////////////////////////////////////////////////////////////////////////
ScriptItem::ScriptItem( ItemType i ) : id( 0 ), type( i ), isFolder( false )
//////////////////////////////////////////////////////////////////////////////////////////
{
}

// Destructor ////////////////////////////////////////////////////////////////////////////
ScriptItem::~ScriptItem( void )
//////////////////////////////////////////////////////////////////////////////////////////
{
}

//////////////////////////////////////////////////////////////////////////////////////////
void ScriptItem::DisplayHelp
//////////////////////////////////////////////////////////////////////////////////////////
// Display the help
// 
(
 CWnd *targetWindow
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    targetWindow->SetWindowText( help.c_str() );
}


//////////////////////////////////////////////////////////////////////////////////////////
list< ScriptItem * > *Command::Clone( bool &rootOnly )
//////////////////////////////////////////////////////////////////////////////////////////
// Clones a command.
//////////////////////////////////////////////////////////////////////////////////////////
{
    list< ScriptItem * > *l = new list< ScriptItem * >;
    Command *newCmd = new Command;
    *newCmd = *this;
    l->push_back( newCmd );
    return l;
}

//////////////////////////////////////////////////////////////////////////////////////////
list< ScriptItem * > *ConditionalCommand::Clone( bool &rootOnly )
//////////////////////////////////////////////////////////////////////////////////////////
// Clones a command.
//////////////////////////////////////////////////////////////////////////////////////////
{
    list< ScriptItem * > *l = new list< ScriptItem * >;
    ConditionalCommand *newCmd = new ConditionalCommand;
    *newCmd = *this;
    l->push_back( newCmd );
    return l;
}

//////////////////////////////////////////////////////////////////////////////////////////
list< ScriptItem * > *ConditionalText::Clone( bool &rootOnly )
//////////////////////////////////////////////////////////////////////////////////////////
// Clones a command.
//////////////////////////////////////////////////////////////////////////////////////////
{
    list< ScriptItem * > *l = new list< ScriptItem * >;
    ConditionalText*newCmd = new ConditionalText;
    *newCmd = *this;
    l->push_back( newCmd );
    return l;
}


//////////////////////////////////////////////////////////////////////////////////////////
list< ScriptItem * > *ConditionalTeleport::Clone( bool &rootOnly )
//////////////////////////////////////////////////////////////////////////////////////////
// Clones a command.
//////////////////////////////////////////////////////////////////////////////////////////
{
    list< ScriptItem * > *l = new list< ScriptItem * >;
    ConditionalTeleport*newCmd = new ConditionalTeleport;
    *newCmd = *this;
    l->push_back( newCmd );
    return l;
}

//////////////////////////////////////////////////////////////////////////////////////////
list< ScriptItem * > *AFolder::Clone( bool &rootOnly )
//////////////////////////////////////////////////////////////////////////////////////////
// Clones a folder, returns NULL (you can't add a folder..)
//////////////////////////////////////////////////////////////////////////////////////////
{
    return NULL;
}

//////////////////////////////////////////////////////////////////////////////////////////
list< ScriptItem * > *Keyword::Clone( bool &rootOnly )
//////////////////////////////////////////////////////////////////////////////////////////
// Clones a keyword
//////////////////////////////////////////////////////////////////////////////////////////
{
    rootOnly = true;

    list< ScriptItem * > *l = new list< ScriptItem * >;
    Keyword *kw = new Keyword;
    *kw = *this;
    
    kw->name = "<undefined>";
    kw->displayName = name;

    l->push_back( kw );
    return l;
}

//////////////////////////////////////////////////////////////////////////////////////////
list< ScriptItem * > *ScriptContainer::Clone( bool &rootOnly )
//////////////////////////////////////////////////////////////////////////////////////////
// Clones a script container. Returns NULL, you can't clone a script container.
//////////////////////////////////////////////////////////////////////////////////////////
{
    return NULL;
}


ScriptContainer::~ScriptContainer(){
    // Delete all script items executed by this keyword.
    list< ScriptItem * >::iterator i;
    for( i = script.begin(); i != script.end(); i++ ){
        delete *i;
    }
}
//////////////////////////////////////////////////////////////////////////////////////////
void ScriptContainer::InsertItem
//////////////////////////////////////////////////////////////////////////////////////////
// Insert the 
//
(
 ScriptItem *item,       // The item to insert.
 ScriptItem *insertAfter // Insert after this this.
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    list< ScriptItem * >::iterator i;
    for( i = script.begin(); i != script.end(); i++ ){
        if( (*i) == insertAfter ){
            i++;
            script.insert( i, item );
            return;
        }
    }
    script.push_back( item );
}

//////////////////////////////////////////////////////////////////////////////////////////
bool ScriptContainer::MoveItemUp
//////////////////////////////////////////////////////////////////////////////////////////
// Moves the given item up one step.
// 
(
 ScriptItem *item // The item
)
// Return: bool, true if the item was moved up
//////////////////////////////////////////////////////////////////////////////////////////
{
    list< ScriptItem * >::iterator i;
    for( i = script.begin(); i != script.end(); i++ ){
        if( *i == item ){
            // If this is already the 1st element of the list.
            if( i == script.begin() ){
                return false;
            }
            
            ScriptItem *item = *i;
       
            i = script.erase( i );
            i--;
            script.insert( i, item );

            return true;
        }
    }

    return false;
}
//////////////////////////////////////////////////////////////////////////////////////////
bool ScriptContainer::MoveItemDown
//////////////////////////////////////////////////////////////////////////////////////////
// Moves the given item down one step.
// 
(
 ScriptItem *item // The item
)
// Return: bool, true if the item was moved down.
//////////////////////////////////////////////////////////////////////////////////////////
{
    list< ScriptItem * >::iterator i;
    for( i = script.begin(); i != script.end(); i++ ){
        if( *i == item ){
            // If this is already the last element of the list
            list< ScriptItem * >::iterator next = i;
            next++;
            if( next == script.end() ){
                return false;
            }
            
            ScriptItem *item = *i;
       
            i = script.erase( i );
            i++;
            script.insert( i, item );

            return true;
        }
    }

    return false;
}

//////////////////////////////////////////////////////////////////////////////////////////
void ScriptContainer::DeleteItem
//////////////////////////////////////////////////////////////////////////////////////////
// Deletes the item
// 
(
 ScriptItem *item // The item to delete.
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    list< ScriptItem * >::iterator i;
    for( i = script.begin(); i != script.end(); i++ ){
        if( *i == item ){
            delete *i;
            script.erase( i );
            return;
        }
    }
}

//////////////////////////////////////////////////////////////////////////////////////////
void Command::Edit( CTreeCtrl &tree, HTREEITEM h )
//////////////////////////////////////////////////////////////////////////////////////////
// Can't edit a single command.
//////////////////////////////////////////////////////////////////////////////////////////
{
    return;
}

//////////////////////////////////////////////////////////////////////////////////////////
void ConditionalCommand::Edit
//////////////////////////////////////////////////////////////////////////////////////////
// Edit a conditional command
// 
(
 CTreeCtrl &tree, // 
 HTREEITEM h // 
)
//////////////////////////////////////////////////////////////////////////////////////////
{
}

//////////////////////////////////////////////////////////////////////////////////////////
void ConditionalText::Edit
//////////////////////////////////////////////////////////////////////////////////////////
// Edit a conditional command
// 
(
 CTreeCtrl &tree, // 
 HTREEITEM h // 
)
//////////////////////////////////////////////////////////////////////////////////////////
{
}

//////////////////////////////////////////////////////////////////////////////////////////
void ConditionalTeleport::Edit
//////////////////////////////////////////////////////////////////////////////////////////
// Edit a conditional command
// 
(
 CTreeCtrl &tree, // 
 HTREEITEM h // 
)
//////////////////////////////////////////////////////////////////////////////////////////
{
}

//////////////////////////////////////////////////////////////////////////////////////////
void Keyword::Edit( CTreeCtrl &tree, HTREEITEM h )
//////////////////////////////////////////////////////////////////////////////////////////
// Edit a keyword
//////////////////////////////////////////////////////////////////////////////////////////
{
}
//////////////////////////////////////////////////////////////////////////////////////////
void Keyword::UpdateName( void )
//////////////////////////////////////////////////////////////////////////////////////////
// Updates the keyword's name
// 
//////////////////////////////////////////////////////////////////////////////////////////
{
    if( keywords.empty() ){
        name = "<undefined>";
        displayName = "<undefined>";
    }else{
        name = "";
        list< string >::iterator i;
        for( i = keywords.begin(); i != keywords.end(); ){
            name += (*i);
            i++;
            if( i != keywords.end() ){
                name += ", ";
            }
        }
        displayName = name;
    }
}

//////////////////////////////////////////////////////////////////////////////////////////
void AFolder::Edit( CTreeCtrl &tree, HTREEITEM h )
//////////////////////////////////////////////////////////////////////////////////////////
// Edit a folder
//////////////////////////////////////////////////////////////////////////////////////////
{
    // Cannot edit a folder.
}

//////////////////////////////////////////////////////////////////////////////////////////
void ScriptContainer::Edit( CTreeCtrl &tree, HTREEITEM h )
//////////////////////////////////////////////////////////////////////////////////////////
// Edit a script container.
//////////////////////////////////////////////////////////////////////////////////////////
{
    // Cannot edit a raw script container.
}


//////////////////////////////////////////////////////////////////////////////////////////
void Commands::GetCmdList
//////////////////////////////////////////////////////////////////////////////////////////
// Returns all the known commands.
// 
(
 list< Command * > &cmdList // The list of commands.
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    /*list< ScriptItem * >::iterator i;
    for( i = itemList.begin(); i != itemList.end(); i++ ){
        if( typeid( *(*i) ) == typeid( Command ) ){
            cmdList.push_back( static_cast< Command * >( *i ) );
        }
    }*/
}

//////////////////////////////////////////////////////////////////////////////////////////
void ScriptItem::Save
//////////////////////////////////////////////////////////////////////////////////////////
// Save a script item
// 
(
 WDAFile &o // The data stream
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    o.Write( (DWORD)type );
    o.Write( id );

    SaveImp( o );
}

//////////////////////////////////////////////////////////////////////////////////////////
void ScriptItem::Load
//////////////////////////////////////////////////////////////////////////////////////////
// Load a script item
// 
(
 WDAFile &i, // The data stream
 DWORD ver   // The stream's version
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    LoadImp( i, ver );
}

// Commands do not save/load anything as their type and Id already load the right
// command.
void Command::SaveImp( WDAFile &o ){
}
void Command::LoadImp( WDAFile &i, DWORD ver ){
}


//////////////////////////////////////////////////////////////////////////////////////////
void ConditionalCommand::SaveImp
//////////////////////////////////////////////////////////////////////////////////////////
// Save
// 
(
 WDAFile &o // 
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    o.Write( rel );
    o.Write( leftType );
    o.Write( rightType );
    o.Write( leftVal );
    o.Write( rightVal );
    o.Write( val );
    o.Write( to );
}
//////////////////////////////////////////////////////////////////////////////////////////
void ConditionalCommand::LoadImp
//////////////////////////////////////////////////////////////////////////////////////////
// Load
// 
(
 WDAFile &i, // 
 DWORD ver // 
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    i.Read( rel );
    i.Read( leftType );
    i.Read( rightType );
    i.Read( leftVal );
    i.Read( rightVal );
    i.Read( val );
    i.Read( to );
}

//////////////////////////////////////////////////////////////////////////////////////////
void ConditionalText::SaveImp
//////////////////////////////////////////////////////////////////////////////////////////
// Save
// 
(
 WDAFile &o // 
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    o.Write( rel );
    o.Write( leftType );
    o.Write( rightType );
    o.Write( leftVal );
    o.Write( rightVal );
    o.Write( txt );
}
//////////////////////////////////////////////////////////////////////////////////////////
void ConditionalText::LoadImp
//////////////////////////////////////////////////////////////////////////////////////////
// Load
// 
(
 WDAFile &i, //
 DWORD ver
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    i.Read( rel );
    i.Read( leftType );
    i.Read( rightType );
    i.Read( leftVal );
    i.Read( rightVal );
    i.Read( txt );
}

//////////////////////////////////////////////////////////////////////////////////////////
void ConditionalTeleport::SaveImp
//////////////////////////////////////////////////////////////////////////////////////////
// Save
// 
(
 WDAFile &o // 
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    o.Write( rel );
    o.Write( leftType );
    o.Write( rightType );
    o.Write( leftVal );
    o.Write( rightVal );
    o.Write( X );
    o.Write( Y );
    o.Write( WL );
}
//////////////////////////////////////////////////////////////////////////////////////////
void ConditionalTeleport::LoadImp
//////////////////////////////////////////////////////////////////////////////////////////
// Load
// 
(
 WDAFile &i, //
 DWORD ver
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    i.Read( rel );
    i.Read( leftType );
    i.Read( rightType );
    i.Read( leftVal );
    i.Read( rightVal );
    i.Read( X );
    i.Read( Y );
    i.Read( WL );
}

//////////////////////////////////////////////////////////////////////////////////////////
void Keyword::SaveImp
//////////////////////////////////////////////////////////////////////////////////////////
// Save
// 
(
 WDAFile &o // 
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    o.Write( (DWORD)kwtype );
    o.Write( (DWORD)rel );
    o.Write( txt );
    o.Write( (DWORD)keywords.size() );
    list< string >::iterator i;
    for( i = keywords.begin(); i != keywords.end(); i++ ){
        o.Write( (*i) );        
    }

    ScriptContainer::SaveImp( o );
}
//////////////////////////////////////////////////////////////////////////////////////////
void Keyword::LoadImp
//////////////////////////////////////////////////////////////////////////////////////////
// Load
// 
(
 WDAFile &i, // 
 DWORD ver
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    DWORD size;
    i.Read( (DWORD &)kwtype );
    i.Read( (DWORD &)rel );
    i.Read( txt );
    i.Read( size );    
    DWORD z;
    for( z = 0; z != size; z++ ){
        string kw;
        i.Read( kw );
        keywords.push_back( kw );
    }
    if( kwtype == Intro ){
        SetName( "Intro Text" );
        SetDisplayName( "Intro Text" );
    }else if( kwtype == End ){
        SetName( "Default Text" );
        SetDisplayName( "Default Text" );
    }else if( kwtype == Death ){
		SetName( "OnDeath" );
		SetDisplayName( "OnDeath" );
	}else if( kwtype == Bye ){
		SetName( "Bye" );
		SetDisplayName( "Bye" );
	}else{
        UpdateName();
    }

    ScriptContainer::LoadImp( i, ver );
}

void AFolder::SaveImp( WDAFile &o ){
    throw "A folder can never exist under an NPC.";
}

void AFolder::LoadImp( WDAFile &i, DWORD ver ){
    throw "It is impossible to load a folder."; 
}

//////////////////////////////////////////////////////////////////////////////////////////
void ScriptContainer::SaveImp
//////////////////////////////////////////////////////////////////////////////////////////
// Saves a script container.
// 
(
 WDAFile &o // 
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    o.Write( (DWORD)script.size() );
    list< ScriptItem * >::iterator i;
    for( i = script.begin(); i != script.end(); i++ ){
        (*i)->Save( o );
    }
}

//////////////////////////////////////////////////////////////////////////////////////////
void ScriptContainer::LoadImp
//////////////////////////////////////////////////////////////////////////////////////////
// Load a script container.
// 
(
 WDAFile &i, // 
 DWORD ver // 
)
//////////////////////////////////////////////////////////////////////////////////////////
{
    DWORD size;
    DWORD z;
    i.Read( size );
    for( z = 0; z != size; z++ ){
        // Read the ScriptItem header.
        ItemType type;
        DWORD id;
        i.Read( (DWORD &)type );
        i.Read( id );

        bool foo = true;
        // Create that script item.
        list< ScriptItem * > *lsi = Commands::GetInstance()->CreateScriptItem( id, type, foo );

        if( lsi == NULL ){
            continue;
        }
        // Only load the 1st item in the cloned list, any other item is extra
        // which exist by itself in the saved file.
        if( lsi->begin() != lsi->end() ){            
            (*lsi->begin())->Load( i, ver );
        }

        script.push_back( *lsi->begin() );

        delete lsi;      
    }
}